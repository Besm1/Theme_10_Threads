Возник у меня вопрос с заданием 10_3

Задание само, а именно описание методов deposit и talk мне показалось не очень похожим на реальность, и я решил его
немного к реальности приблизить. А именно:
- если два потока обращаются к одному и тому же ресурсу (balanct), то перед обращением к нему каждый поток должен
  лочить замок данного ресурса
- после завершения операции этот поток должен разлочить залоченный замок
- если говорят, что "транзакция занимает какое-то время", то и sleep() надо вызывать ровно в том месте, где идёт
  транзакция, т.е. между залочкой и разлочкой в методе пополнения, а не после выполнения всех операций по внесению депозита.

Написал я код к такой изменённой задаче, но на первых же итерациях происходит взаимоблокировка потоков.  Для отладки я
написал "болтливую" версию, где каждый чих программы сопровождается выводом в консоль информации о выполняемых действиях.
Вот ссылка на решение - https://github.com/Besm1/Theme_10_Threads/blob/master/module_10_3_1.py

И вот что интересно: если реализовать задержку по заданию, т.е. задержку ставить между транзакциями ("после выполнения
всех операций", как написано в п.5 описания к методу deposit), - в строке 32, при закомментированной 22, - то
алгоритм доходит до конца, оба потока выполняют все свои операции.

Если реализовать задержку как время на проведение транзакции, - строка 22 в коде раскомментирована,
32 закомментирована, - то как раз и происходит взаимоблокировка.

В файле Screenshot_10_3.png иллюстрация к моменту зависания.

Вот что произошло: 1-й поток пытался залочить доступ к balance, но пока собирался это сделать, 2-й поток успел пролезть
и залочил ресурс для снятия денег.

2-й поток на итерации №0 залочил, снял деньги, разлочил, но управление осталось за 2-м потоком, и он перешёл к итерации №1.
Он получил запрос на снятие суммы, превышающей баланс, после чего залочил доступ к balance в конце итерации №1.

Но управление снова осталось у 2-го потока, он снова получает запрос на снятие большей суммы, чем остаток баланса, он
пытается на итерации №2 залочить замок, но он уже залочен, и поток 2 переходит в ожидание возможности залочить замок. Ждём.

Управление перешло к потоку 1, но и он находится в ожидании возможности залочить замок, а он уже залочен. Ждём.

Оба потока ждут. Зависание.

Вопрос: в чём дефект постановки задачи?
Я думаю, что дефект в обработке запроса на снятие денег в количестве, превышающем баланс. Скорее всего блокировка
доступа здесь неуместна, надо просто ждать достаточного количества денег на балансе (тогда произвести снятие) или
завершения работы потока пополнения (тогда выйти из цикла, тем самым завершив работу и не выдав денег по последнему запросу).